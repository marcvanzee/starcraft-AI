
/* The agent is written exactly as explained in the document 
 * "Reasoning cycle" that can be found on Google Docs.
 *
 * ---------------------- reasoning cycle ----------------------------------------------------------
 *
 * the reasoning cycle is as follows (for a more informal description, see Google Docs document)
 * TODO: make a flowchart out of this
 *
 * 1. SENSE				
 * *  Receive joint_plans from other agents		// can be received at any moment, due to synchronization
 * a. Receive game_parameters
 *
 * 2. REASON
 * a. Remember cur_priority of cur_plan
 *	  Select subgoal with highest priority,		 
 *	  Remember priority as new_priority,
 * b. Process joint_plans
 *    If joint_plan is chosen:
 *	  	new_plan = joint_plan
 *	  	new_priority = joint_plan_priority
 *    Else:	select own_plan based on 1(a)
 *		new_plan = own_plan
 *		new_priority = own_plan_priority
 *	  						
 * 3. ACT
 * a. If new_priority > cur_priority
 *		execute new_plan
 * b. If new_plan is a joint plan: send plan
 *
 *
 * ---------------- explanation of beliefs that are used -----------------------------------------
 *
 * the character of the agent is defined as the willingness to attack (WTA) and it is 
 * assigned once when the game starts.
 * 		wta(X), with X € [0,1,..,10]
 *
 * There are two subgoals, which both are assigned a priority at the beginning of each update
 * the winning priority will be the goal that the agent will try to pursue
 * these are the subgoals together with their priority
 * the priority depends on the WTA and the current situation
 * 		subgoal(Subgoal, X), with Subgoal € [attack,defend] and X € [0,1,...,10]
 *
 * beliefs that are assigned to the agent at the beginning of the game and do not change
 * 		baseCP(X,Y)			center point of the base
 * 		numUnits(X)			number of units
 *
 * beliefs that are assigned to the agent are every game update
 * 		unitsCP(X,Y)     	center point of own units
 * 		baseHP(X)			health Points of the own base
 * 		numEnemyUnits(X)	number of enemy units that are currently visible
 * 		enemies(L)			a list that contains the location and the HP of the visible enemies
 *		enemyBases(L)		a list that contains the location and the HP of the visible bases of the enemy
 *
 */

BeliefUpdates:
	// initial beliefs, when game starts
	{true} 				SetTeamMate(X) 		{teamMate(X)}
	{true} 				SetWta(X) 			{wta(X)}
	{true} 				SetUnits(X)			{numUnits(X)}
	{true}				SetBaseCP(Pos)		{baseCP(Pos)}									// Pos = [X,Y]
	
	// updated beliefs, when game updates
	{numUnits(X)}		DestroyUnit()		{not numUnits(X), numUnits(X-1)}
	{baseHP(X)}			SetBaseHP(Y)		{not baseHP(X), baseHP(Y)}
	{ownCP(Pos)}		SetOwnCP(PosNew)	{not ownCP(Pos), ownCP(PosNew)}					// Pos,PosNew = [X,Y]
	{numEnemies(X)}		SetNumEnemies(Y)	{not numEnemies(X), numEnemies(Y) }
	{enemies(Pos)}		SetEnemies(PosNew)	{not enemies(Pos), enemies(PosNew)}
	{enemyBases(L)}		SetEnemyBases(Lnew)	{not enemyBases(L), enemyBases(Lnew)}
	
	// other beliefs, for internal processing
	{true}				SetBusy()			{busy}
	{busy}				SetIdle()			{not busy}
	{subgoal(X,Y)}		SetSubgoal(X1,Y1)	{not subgoal(X,Y), subgoal(X1,Y1)}
	{cur_priority(X)}	RememberPriority(Y)	{not cur_priority(X), cur_priority(Y)}
	{true}				SetJointPlan(Pl,Pr)	{jointPlan(Pl,Pr)}
	{jointPlan(Pl,Pr)}	RemoveJointPlan()	{not jointPlain(Pl,Pr)}
	
	// temp
	{true}				SetPlan(X,Y)		{not finished}

Beliefs:
// initial beliefs, required for beliefupdates
	numUnits(0).
	baseHP(0).
	ownCP(0).
	numEnemies(0).
	enemies(0).
	enemyBases(0).
	subgoal(0,0).
	cur_priority(0).
	
	
Plans:
	@starcraft(hello(),_)
		
PC-rules:	
 	//----------------------- game initializes -------------------------------------------
	event(gameStarted( Wta, Units, BaseLocation ), starcraft) <- true |
	{
		SetWta(Wta);
		SetUnits(Units);
		SetBaseCP(BaseLocation);
		print(gamestarted)
	}
	
	// ---------------------- receiving a joint plan ------------------------------------
	message( TeamMate, ProposalPlan, Priority ) <- teamMate( TeamMate ) | 
	{
		SetJointPlan(ProposalPlan, Priority)
	}

	// ----------------------- reasoning step #1b, game update ---------------------------
	event(gameUpdate( UnitCP, BaseHP, NumEnemies, EnemyUnitList, EnemyBuildingList ), starcraft) <- wta(WTA) and not busy |
	{
	[
		SetBusy();
		
		// receive all information
		SetOwnCP(UnitCP);
		SetBaseHP(BaseHP);
		SetNumEnemies(NumEnemies);
		SetEnemies(EnemyUnitList);
		SetEnemyBases(EnemyBuildingList);
		
		// advance to next reasoning step
		determineSubgoals(0)
	]
	}
	
	// ----------------------- reasoning step #2a, determine subgoal priorities ----------
	determineSubgoals(_) <- baseCP(BaseCP) and baseHP(BaseHP) and numUnits(NumUnits) and
							unitCP(UnitCP) and numEnemies(NumEnemies) and enemies(Enemies) and
							enemyBases(EnemyBases) and wta(WTA) | 
	{
		// remember the current priority, if we are performing a plan
		if B(subgoal(_,Pr)) then 
		{
			RememberPriority(Pr)
		};
		
		@starcraft(allocatePriorities( BaseCP, BaseHP, NumUnits, UnitCP, NumEnemies, Enemies, EnemyBases, WTA ), Ret);
		
		if B(Ret = [actionresult(AttackPr, DefendPr)]) then 
		{
			// choose the subgoal that has the highest priority
			if B(AttackPr > DefendPr) then {
				SetSubgoal(attack, AttackPr)
			} else {
				SetSubgoal(defend, DefendPr)
			}
		};
		
		processJointPlans(0)
	}
	
	// ----------------------- reasoning step #2b, process joint plans -----------------
	processJointPlans(_) <- teamMate(TeamMate) | {	
	
		// did we receive a plan?				
		if B(jointPlain(Plan, HisPriority)) then {
		
			// do we accept the plan?
			if B( subgoal(attack, MyPriority) and HisPriority > MyPriority) then {
				SetPlan(Plan, HisPriority);
				informObeyJointPlan(TeamMate, Plan)
			} else {
			
			// we did not accept the plan
				informIgnoreJointPlan(TeamMate, Plan );
				selectPlan()
			}
			
		// we did not have receive a plan
		} else {
			selectPlan()
		};
		
		SetIdle()
	}
	
	selectPlan() <- true | {
		print(selectingPlan)
	}
	
	event(ownUnitDestroyed(UnitsLeft), starcraft ) <- true |
	{
		print(ownUnitDestroyed(UnitsLeft));
		DestroyUnit()
	}
	
	event( teamMate(teammate), starcraft ) <- true |
	{
		SetTeamMate( teammate )
	}
	
	// reply to proposal negative
	informIgnoreJointPlan( TeamMate, ProposalPlan ) <- true |
	{
		send( TeamMate, inform, ignoreJointPlan( ProposalPlan ) )
	}
	
	// reply to proposal positive
	informObeyJointPlan( TeamMate, ProposalPlan ) <- true |
	{
		send( TeamMate, inform, obeyJointPlan( ProposalPlan ) )
	}