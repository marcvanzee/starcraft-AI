
/* The agent is written exactly as explained in the document 
 * "Reasoning cycle" that can be found on Google Docs.
 *
 * ---------------------- reasoning cycle ----------------------------------------------------------
 *
 * the reasoning cycle can be found in the flow chart of Google docs
 *
 *
 * ---------------- explanation of beliefs that are used -----------------------------------------
 *
 * the character of the agent is defined as the willingness to attack (WTA) and it is 
 * assigned once when the game starts.
 * 		wta(X), with X € [0,1,..,10]
 *
 * There are two subgoals, which both are assigned a priority at the beginning of each update
 * the winning priority will be the goal that the agent will try to pursue
 * these are the subgoals together with their priority
 * the priority depends on the WTA and the current situation
 * 		subgoal(Subgoal, X), with Subgoal € [attack,defend] and X € [0,1,...,10]
 *
 * beliefs that are assigned to the agent at the beginning of the game and do not change
 * 		baseCP(X,Y)			center point of the base
 * 		numUnits(X)			number of units
 *
 * beliefs that are assigned to the agent are every game update
 * 		unitsCP(X,Y)     	center point of own units
 * 		baseHP(X)			health Points of the own base
 * 		numEnemyUnits(X)	number of enemy units that are currently visible
 * 		enemies(L)			a list that contains the location and the HP of the visible enemies
 *		enemyBases(L)		a list that contains the location and the HP of the visible bases of the enemy
 *
 */

BeliefUpdates:
	// initial beliefs, when game starts
	{true} 					SetTeamMate(X) 		{teamMate(X)}
	{true} 					SetWta(X) 			{wta(X), wtaTresholdInUnits(2*X)}
	{true} 					SetUnits(X)			{numUnits(X)}
	{true}					SetBaseCP(Pos)		{baseCP(Pos)}									// Pos = [X,Y]
	{true}					SetCoBase(X,Y)		{coBase(X,Y)}
	
	// updated beliefs, when game updates
	{numUnits(X)}			DestroyUnit()		{not numUnits(X), numUnits(X-1)}
	{baseHP(X)}				SetBaseHP(Y)		{not baseHP(X), baseHP(Y)}
	{ownCP(Pos)}			SetOwnCP(PosNew)	{not ownCP(Pos), ownCP(PosNew)}					// Pos,PosNew = [X,Y]
	{numEnemies(X)}			SetNumEnemies(Y)	{not numEnemies(X), numEnemies(Y) }
	{enemies(Pos)}			SetEnemies(PosNew)	{not enemies(Pos), enemies(PosNew)}
	{enemyBases(L)}			SetEnemyBases(Lnew)	{not enemyBases(L), enemyBases(Lnew)}
	
	// other beliefs, for internal processing
	{true}					SetBusy()			{busy}
	{true}					SetIdle()			{not busy}
	{subgoal(X,Y)}			SetSubgoal(X1,Y1)	{not subgoal(X,Y), subgoal(X1,Y1)}
	{curPriority(X)}		RememberPriority(Y)	{not curPriority(X), curPriority(Y)}
	
	{currentPlan(Id,X1,X2)}	SetPlan(IdNew,Y1,Y2){not currentPlan(Id, X1,X2), currentPlan(IdNew, Y1,Y2)}
	{newPlan(X)}			SetNewPlan(X2)		{not newPlan(X), newPlan(X2)}
	{currentPlan(Id,X1,X2)} PlanFinished()		{not currentPlan(Id, X1,X2), currentPlan(0,[],0)}
	
	{coPlan(X)}				SetCoPlan(Y)		{not coPlan(X), coPlan(Y)}
	
	// communication
	{true}					PlanShared()		{planShared}
	{true}					PlanRcvd()			{planRcvd}
	{jointActFinished(X)}	JointActFinsh()		{not jointActFinished(X), jointActFinished(1)}
	
	{true}					ResetComm()			{not planShared, not planRcvd}
	{jointActFinished(X)}	ResetJointAct()		{not jointActFinished(X), jointActFinished(0)}	

Beliefs:
// beliefs required for belief updates
	numUnits(0).
	baseHP(0).
	ownCP(0).
	numEnemies(0).
	enemies(0).
	enemyBases(0).
	subgoal(0,0).
	curPriority(0).
	
	newPlan(0).
	currentPlan(0,[],0). // currentPlan(Id,Plan,Subgoal)
	
	coPlan(0).
	jointPlanFinished(0).
	
	wtaTresHoldToAttack(0.5).
	
	weakestBase([[Id,Min]],Id,Min).

	weakestBase([[H1,H2],[K1,K2]|T],New,M) :-
    	H2 =< K2,
    	weakestBase([[H1,H2]|T],New,M).

	weakestBase([[H1,H2],[K1,K2]|T],New,M) :-
    	H2 > K2,
    	weakestBase([[K1,K2]|T],New,M).

	selectPlan(PlanId, Pr, Subgoal) :-
		plan(PlanId, Pr, Subgoal, _ , _).

	// description of the plans: plan(Identifier, Priority, Joint, Subgoal, Plan), where
	// Identifier: 	a number denoting the unique identity of the plan
	// Joint: 		a boolean denoting whether this is a joint plan or not
	// Subgoal:		the subgoal that this plan belongs to: attack/defend
	// Plan: 		the plan
	// plan ( id, priority, subgoal, jointPlan, singlePlan )
	
	// DEFENDING
	plan( 0,10, 	defend, [defendBuilding(P,joint)], [defendBuilding(P,single)] ) :- numUnits(X), numEnemies(Y), (X < Y/2), ownCP(P).
	plan( 1, 9,		defend, [defendBuilding(P,joint)], [defendBuilding(P,single)] ) :- numUnits(X), numEnemies(Y), (X < Y/2), ownCP(P).
	plan( 2, 8,		defend, [defendBuilding(P,joint)], [defendBuilding(P,single)] ) :- numUnits(X), numEnemies(Y), (X < Y/2), ownCP(P).
	
	plan( 10, 10,	defend, [], [defendBuilding(P,single)] ) :- numUnits(X), numEnemies(Y), (X >= Y/2), ownCP(P).
	plan( 11, 9,	defend, [], [defendBuilding(P,single)] ) :- numUnits(X), numEnemies(Y), (X >= Y/2), ownCP(P).
	plan( 12, 8,	defend, [], [defendBuilding(P,single)] ) :- numUnits(X), numEnemies(Y), (X >= Y/2), ownCP(P).

	plan( 20, 7,	defend, [], [defendBuilding(P,single)] ) :- enemyBases(X), not( X = []), ownCP(P).
	plan( 21, 6,	defend, [], [defendBuilding(P,single)] ) :- enemyBases(X), not( X = []), ownCP(P).
	plan( 22, 5,	defend, [], [defendBuilding(P,single)] ) :- enemyBases(X), not( X = []), ownCP(P).
	
	plan( 30, 7,	defend, [], [exploreDefensive] ) :- enemyBases(X), (X = []).
	plan( 31, 6,	defend, [], [exploreDefensive] ) :- enemyBases(X), (X = []).
	plan( 32, 5,	defend, [], [exploreDefensive] ) :- enemyBases(X), (X = []).
	
	// ATTACKING
	plan( 100,10,	attack, [gatherForAttackBuilding(X,joint), attack(X)], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits >= Z/2).
	plan( 101, 9,	attack, [gatherForAttackBuilding(X,joint), attack(X)], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits >= Z/2).
	plan( 102, 8,	attack, [gatherForAttackBuilding(X,joint), attack(X)], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits >= Z/2).
	
	plan( 110,10,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits < Z/2).
	plan( 111, 9,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits < Z/2).
	plan( 112, 8,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits < Z/2).

	plan( 120,10,	attack, [], [exploreAggressive] ) :- enemyBases(L), (L = []).
	plan( 121, 9,	attack, [], [exploreAggressive] ) :- enemyBases(L), (L = []).
	plan( 122, 8,	attack, [], [exploreAggressive] ) :- enemyBases(L), (L = []).

	plan( 130, 7,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta >= wtaTresholdToAttack.
	plan( 131, 6,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta >= wtaTresholdToAttack.
	plan( 132, 5,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta >= wtaTresholdToAttack.
	
	plan( 140, 7,	attack, [], [defendBuilding(P)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta < wtaTresholdToAttack, ownCP(P).
	plan( 141, 6,	attack, [], [defendBuilding(P)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta < wtaTresholdToAttack, ownCP(P).
	plan( 142, 5,	attack, [], [defendBuilding(P)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta < wtaTresholdToAttack, ownCP(P).

	plan( 150, 7,	attack, [], [exploreAggressive] ) :- enemyBases(L), (L = []).
	plan( 151, 6,	attack, [], [exploreAggressive] ) :- enemyBases(L), (L = []).
	plan( 152, 5,	attack, [], [exploreAggressive] ) :- enemyBases(L), (L = []).
	
Plans:
	@starcraft(hello(),_)

PC-rules:
 	//----------------------- game initializes -------------------------------------------
	event(gameStarted( Wta, Units, BaseLocation ), starcraft) <- true |
	{
	[
		SetWta(Wta);
		SetUnits(Units);
		SetBaseCP(BaseLocation);
		print(gamestarted)
	]
	}

	// ----------------------- game ---------------------------
	event(gameUpdate( UnitCP, BaseHP, NumEnemies, EnemyUnitList, EnemyBuildingList ), starcraft) <- wta(WTA) and not busy |
	{
	[
		SetBusy();
		
		// receive all information
		SetOwnCP(UnitCP);
		SetBaseHP(BaseHP);
		SetNumEnemies(NumEnemies);
		SetEnemies(EnemyUnitList);
		SetEnemyBases(EnemyBuildingList);
		
		// advance to next reasoning step
		determineSubgoals(0)
	]
	}

	// ----------------------- determine subgoal priorities ----------
	determineSubgoals(_) <- baseCP(BaseCP) and baseHP(BaseHP) and numUnits(NumUnits) and
							ownCP(UnitCP) and numEnemies(NumEnemies) and enemies(Enemies) and
							enemyBases(EnemyBases) and wta(WTA) and subgoal(_,CurPr) | 
	{
	[	
		@starcraft(allocatePriorities( BaseCP, BaseHP, NumUnits, UnitCP, NumEnemies, Enemies, EnemyBases, WTA ), Ret);
		
		// remember the current priority to compare later
		RememberPriority(CurPr);
		
		if B(Ret = [actionresult([AttackPr, DefendPr])]) then 
		{
			print(attackPriority(AttackPr));
			print(defendPriority(DefendPr));
			// choose the subgoal that has the highest priority
			if B(AttackPr > DefendPr) then {
				SetSubgoal(attack, AttackPr)
			} else {
				SetSubgoal(defend, DefendPr)
			}
		};

		selectPotentialPlans(0)
	]
	}
	
	// ----------------------- selecting the potential plans ----------
	// first select the most relevant plan.
	selectPotentialPlans(_) <- subgoal(Subgoal,NewPr) | 
	{
	[
		B(selectPlan(NewPlanId, NewPr, Subgoal));
		
		SetNewPlan(NewPlanId);
		
		sharePlans(0);
		selectRelevantPlan(0)
	]
	}
	
	// ----------------------- sharing a plan, sending and receiving ----------
	sharePlans(_) <- newPlan(NewPlanId) and teamMate(TeamMate) | {
	[
		send( TeamMate, inform, plan(NewPlanId) );
		PlanShared()
	]
	}
	
	message( TeamMate, inform, _, _, plan( CoPlanId ) ) <- teamMate( TeamMate ) | 
	{
	[
		SetCoPlan(CoPlanId);
		PlanRcvd()
	]
	}
	
	// -----------------------  select most relevant plan ----------
	// see flowchart on Google Docs for a better overview of this method
	selectRelevantPlan(_) <- planShared and planRcvd and 
					newPlan(OwnPlanId) 	and plan(OwnPlanId, OwnPr, OwnSubgoal, OwnJointPlan, OwnSinglePlan) and
					coPlan(CoPlanId) 	and plan(CoPlanId, CoPr, CoSubgoal, CoJointPlan, CoSinglePlan) |
	{
	[
		print(releavantplan(0));
		ResetComm();
		
		if B(not (OwnJointPlan = [])) then 
		{
			if B(not (CoJointPlan = [])) then
			{
				if B(OwnPr > CoPr) then
				{
					if B(not (CoSubgoal = defend)) then
					{
						setPlan(OwnPlanId, OwnJointPlan, joint)
					} else {
						setPlan(OwnPlanId, OwnSinglePlan, single)
					}
				} else if B(OwnPr = CoPr) then 
				{
					setPlan(OwnPlanId, OwnSinglePlan, single)
				} else 
				{
					if B(not (OwnSubgoal = defend)) then
					{
						setPlan(CoPlanId, CoJointPlan, joint)
					} else
					{
						setPlan(OwnPlanId, OwnSinglePlan, single)
					}
				}
			} else
			{
				if B(OwnPr < CoPr and not (CoSubgoal = defend)) then
				{
					setPlan(OwnPlanId, OwnJointPlan, joint)
				} else
				{
					setPlan(OwnPlanId, OwnSinglePlan, single)
				}
			}
		} else
		{
			if B(not(CoJointPlan = []) and not(OwnSubGoal = defend)) then 
			{
				if B(CoPriority =< OwnPriority) then
				{
					setPlan(OwnPlanId, OwnSinglePlan, single)
				} else
				{
					setPlan(CoPlanId, CoJointPlan, joint)
				}
			} else
			{
				setPlan(OwnPlanId, OwnSinglePlan, single)
			}
		}
	]
	}
	
	// ----------------------- execution of plan; only if it differs from the current plan -----------------
	setPlan(NewPlanId, NewPlan, NewPlanType) <- currentPlan(CurrentPlanId, CurrentPlan, CurrentPlanType) |
	{
	[
		if B(not (NewPlanId = CurrentPlanId)) then 
		{
			SetPlan(NewPlanId, NewPlan, NewPlanType);
			executeFirstAction()
		};
		
		SetIdle()
	]
	}
	
	executeFirstAction() <- currentPlan(PlanId, Plan, PlanType) | 
	{
		// first check whether the plan is not empty
		if B( Plan = [Action|Rest] ) then 
		{
			performAction(Action);
			SetPlan(PlanId, Rest, PlanType)
		} else
		{
			PlanFinished()
		}
	}

	executeFirstJointAction() <- currentPlan( PlanId, Plan, joint ) and jointActFinished(1) | 
	{
	[
		if B(Plan = [Action|Rest]) then 
		{
			performAction(Action);
			SetPlan(PlanId, Rest, joint);
			ResetJointAct()
		}
	]
	}
	
	performAction(Action) <- true |
	{
		@starcraft(action(Action), _)
	}
	
	event( ownUnitDestroyed(UnitsLeft), starcraft ) <- true |
	{
		DestroyUnit()
	}
	
	event( teamMate( Teammate, CoBaseX, CoBaseY ), starcraft ) <- true |
	{
		SetTeamMate( Teammate );
		SetCoBase( CoBaseX , CoBaseY )
	}
	
	message( TeamMate, inform, _, _, jointActFinished( PlanId ) ) <- teamMate( TeamMate ) | 
	{
	[
		JointActFinsh()
	]
	}
	
	event( actionPerformed( PlanId ), starcraft ) <- currentPlan( PlanId, Plan, PlanType ) and
										teamMate(TeamMate) | 
	{
		// if we finished an action thats was part of a joint plan, tell the other agent we finished
		if B(PlanType = joint) then 
		{
			send( TeamMate, inform, jointActFinished(PlanId ) );
			executeFirstJointAction()
		} else
		{
			executeFirstAction()
		}
	}