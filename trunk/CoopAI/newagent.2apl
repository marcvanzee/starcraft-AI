
/* The agent is written exactly as explained in the document 
 * "Reasoning cycle" that can be found on Google Docs.
 *
 * ---------------------- reasoning cycle ----------------------------------------------------------
 *
 * the reasoning cycle can be found in the flow chart of Google docs
 *
 *
 * ---------------- explanation of beliefs that are used -----------------------------------------
 *
 * the character of the agent is defined as the willingness to attack (WTA) and it is 
 * assigned once when the game starts.
 * 		wta(X), with X € [0,1,..,10]
 *
 * There are two subgoals, which both are assigned a priority at the beginning of each update
 * the winning priority will be the goal that the agent will try to pursue
 * these are the subgoals together with their priority
 * the priority depends on the WTA and the current situation
 * 		subgoal(Subgoal, X), with Subgoal € [attack,defend] and X € [0,1,...,10]
 *
 * beliefs that are assigned to the agent at the beginning of the game and do not change
 * 		baseCP(X,Y)			center point of the base
 * 		numUnits(X)			number of units
 *
 * beliefs that are assigned to the agent are every game update
 * 		unitsCP(X,Y)     	center point of own units
 * 		baseHP(X)			health Points of the own base
 * 		numEnemyUnits(X)	number of enemy units that are currently visible
 * 		enemies(L)			a list that contains the location and the HP of the visible enemies
 *		enemyBases(L)		a list that contains the location and the HP of the visible bases of the enemy
 *
 */

BeliefUpdates:
	// initial beliefs, when game starts
	{true} 				SetTeamMate(X) 		{teamMate(X)}
	{true} 				SetWta(X) 			{wta(X), wtaTresholdInUnits(2*X)}
	{true} 				SetUnits(X)			{numUnits(X)}
	{true}				SetBaseCP(Pos)		{baseCP(Pos)}									// Pos = [X,Y]
	{true}				SetCoBase(X,Y)		{coBase(X,Y)}
	
	// updated beliefs, when game updates
	{numUnits(X)}		DestroyUnit()		{not numUnits(X), numUnits(X-1)}
	{baseHP(X)}			SetBaseHP(Y)		{not baseHP(X), baseHP(Y)}
	{ownCP(Pos)}		SetOwnCP(PosNew)	{not ownCP(Pos), ownCP(PosNew)}					// Pos,PosNew = [X,Y]
	{numEnemies(X)}		SetNumEnemies(Y)	{not numEnemies(X), numEnemies(Y) }
	{enemies(Pos)}		SetEnemies(PosNew)	{not enemies(Pos), enemies(PosNew)}
	{enemyBases(L)}		SetEnemyBases(Lnew)	{not enemyBases(L), enemyBases(Lnew)}
	
	// other beliefs, for internal processing
	{true}				SetBusy()			{busy}
	{true}				SetIdle()			{not busy}
	{subgoal(X,Y)}		SetSubgoal(X1,Y1)	{not subgoal(X,Y), subgoal(X1,Y1)}
	{curPriority(X)}	RememberPriority(Y)	{not curPriority(X), curPriority(Y)}
	
	{currentPlan(Id,X)}	SetPlan(IdNew,Y)	{not currentPlan(Id, X), currentPlan(IdNew, Y)}
	{newPlan(X)}		SetNewPlan(X2)		{not newPlan(X), newPlan(X2)}
	
	{coPlan(X)}			SetCoPlan(Y)		{not coPlan(X), coPlan(Y)}
	
	{true}				PlanShared()		{planShared}
	{true}				PlanRcvd()			{planRcvd}
	{true}				ResetComm()			{not planShared, not planRcvd}

Beliefs:
// beliefs required for belief updates
	numUnits(0).
	baseHP(0).
	ownCP(0).
	numEnemies(0).
	enemies(0).
	enemyBases(0).
	subgoal(0,0).
	curPriority(0).
	
	newPlan(0).
	currentPlan(0,[]).
	
	coPlan(0).
	
	wtaTresHoldToAttack(0.5).
	
	weakestBase([[Id,Min]],Id,Min).

	weakestBase([[H1,H2],[K1,K2]|T],New,M) :-
    	H2 =< K2,
    	weakestBase([[H1,H2]|T],New,M).

	weakestBase([[H1,H2],[K1,K2]|T],New,M) :-
    	H2 > K2,
    	weakestBase([[K1,K2]|T],New,M).
    	
	
	// DIT WAS FRANK ZIJN IDEE, MARC VIND HET EEN SLECHT IDEE
	// Frank vind dat het weg kan.
	// roundPriority( Pr,   1 ) :- (Pr > 0.95).
	// roundPriority( Pr, 0.9 ) :- (Pr > 0.85).
	// roundPriority( Pr, 0.8 ) :- (Pr > 0.75).
	// roundPriority( Pr, 0.7 ) :- (Pr > 0.65).
	// roundPriority( Pr, 0.6 ) :- (Pr > 0.55).
	// roundPriority( Pr, 0.5 ) :- (Pr > 0.45).
	// roundPriority( Pr, 0.4 ) :- (Pr > 0.35).
	// roundPriority( Pr, 0.3 ) :- (Pr > 0.25).
	// roundPriority( Pr, 0.2 ) :- (Pr > 0.15).
	// roundPriority( Pr, 0.1 ) :- (Pr > 0.5).
	// roundPriority( _, 0 ).

	selectPlan(NewPlanId, NewPr, Subgoal) :-
		plan(NewPlanId, NewPr, Subgoal, _ , _).
	
	//selectSinglePlan(X) :- is(X,1) :-
	//	roundPriority(NewPr, NewPrRounded),
	//	plan(NewPlanId, NewPrRounded, single, Subgoal, _ ).

	// description of the plans: plan(Identifier, Priority, Joint, Subgoal, Plan), where
	// Identifier: 	a number denoting the unique identity of the plan
	// Joint: 		a boolean denoting whether this is a joint plan or not
	// Subgoal:		the subgoal that this plan belongs to: attack/defend
	// Plan: 		the plan
	// plan ( id, priority, subgoal, jointPlan, singlePlan )
	
	// DEFENDING
	plan( 0, 10,	defend, [defendOwnBuilding], [defendOwnBuilding] ) :- numUnits(X), numEnemies(Y), (X < Y/2).
	plan( 1, 9,	defend, [defendOwnBuilding], [defendOwnBuilding] ) :- numUnits(X), numEnemies(Y), (X < Y/2).
	plan( 2, 8,	defend, [defendOwnBuilding], [defendOwnBuilding] ) :- numUnits(X), numEnemies(Y), (X < Y/2).
	
	plan( 10, 10,	defend, [], [defendOwnBuilding] ) :- numUnits(X), numEnemies(Y), (X >= Y/2).
	plan( 11, 9,	defend, [], [defendOwnBuilding] ) :- numUnits(X), numEnemies(Y), (X >= Y/2).
	plan( 12, 8,	defend, [], [defendOwnBuilding] ) :- numUnits(X), numEnemies(Y), (X >= Y/2).

	plan( 20, 7,	defend, [], [defendOwnBuilding] ) :- enemyBases(X), not( X = []).
	plan( 21, 6,	defend, [], [defendOwnBuilding] ) :- enemyBases(X), not( X = []).
	plan( 22, 5,	defend, [], [defendOwnBuilding] ) :- enemyBases(X), not( X = []).
	
	plan( 30, 7,	defend, [], [exploreDefensive, defendOwnBuilding] ) :- enemyBases(X), (X = []).
	plan( 31, 6,	defend, [], [exploreDefensive, defendOwnBuilding] ) :- enemyBases(X), (X = []).
	plan( 32, 5,	defend, [], [exploreDefensive, defendOwnBuilding] ) :- enemyBases(X), (X = []).
	
	// ATTACKING
	plan( 100, 10,	attack, [attack(X)], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits >= Z/2).
	plan( 101, 9,	attack, [attack(X)], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits >= Z/2).
	plan( 102, 8,	attack, [attack(X)], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits >= Z/2).
	
	plan( 110, 10,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits < Z/2).
	plan( 111, 9,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits < Z/2).
	plan( 112, 8,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), numUnits(Y), numEnemies(Z), (Y+wtaTresholdInUnits < Z/2).

	plan( 120,   10,	attack, [], [exploreAggressive, attack] ) :- enemyBases(L), (L = []).
	plan( 121, 9,	attack, [], [exploreAggressive, attack] ) :- enemyBases(L), (L = []).
	plan( 122, 8,	attack, [], [exploreAggressive, attack] ) :- enemyBases(L), (L = []).

	plan( 130, 7,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta >= wtaTresholdToAttack.
	plan( 131, 6,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta >= wtaTresholdToAttack.
	plan( 132, 5,	attack, [], [attackEnemyBuilding(X)] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta >= wtaTresholdToAttack.
	
	plan( 140, 7,	attack, [], [defendOwnBuilding] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta < wtaTresholdToAttack.
	plan( 141, 6,	attack, [], [defendOwnBuilding] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta < wtaTresholdToAttack.
	plan( 142, 5,	attack, [], [defendOwnBuilding] ) :- enemyBases(L), not( L = []), weakestEnemyBase(X), wta < wtaTresholdToAttack.

	plan( 150, 7,	attack, [], [exploreAggressive, attack] ) :- enemyBases(L), (L = []).
	plan( 151, 6,	attack, [], [exploreAggressive, attack] ) :- enemyBases(L), (L = []).
	plan( 152, 5,	attack, [], [exploreAggressive, attack] ) :- enemyBases(L), (L = []).
	
Plans:
	@starcraft(hello(),_)

PC-rules:
 	//----------------------- game initializes -------------------------------------------
	event(gameStarted( Wta, Units, BaseLocation ), starcraft) <- true |
	{
	[
		SetWta(Wta);
		SetUnits(Units);
		SetBaseCP(BaseLocation);
		print(gamestarted)
	]
	}

	// ----------------------- game ---------------------------
	event(gameUpdate( UnitCP, BaseHP, NumEnemies, EnemyUnitList, EnemyBuildingList ), starcraft) <- wta(WTA) and not busy |
	{
	[
		SetBusy();
		
		// receive all information
		SetOwnCP(UnitCP);
		SetBaseHP(BaseHP);
		SetNumEnemies(NumEnemies);
		SetEnemies(EnemyUnitList);
		SetEnemyBases(EnemyBuildingList);
		
		// advance to next reasoning step
		determineSubgoals(0)
	]
	}

	// ----------------------- determine subgoal priorities ----------
	determineSubgoals(_) <- baseCP(BaseCP) and baseHP(BaseHP) and numUnits(NumUnits) and
							ownCP(UnitCP) and numEnemies(NumEnemies) and enemies(Enemies) and
							enemyBases(EnemyBases) and wta(WTA) and subgoal(_,CurPr) | 
	{
	[	
		@starcraft(allocatePriorities( BaseCP, BaseHP, NumUnits, UnitCP, NumEnemies, Enemies, EnemyBases, WTA ), Ret);
		
		// remember the current priority to compare later
		RememberPriority(CurPr);
		
		if B(Ret = [actionresult([AttackPr, DefendPr])]) then 
		{
			print(attackPriority(AttackPr));
			print(defendPriority(DefendPr));
			// choose the subgoal that has the highest priority
			if B(AttackPr > DefendPr) then {
				SetSubgoal(attack, AttackPr)
			} else {
				SetSubgoal(defend, DefendPr)
			}
		};

		selectPotentialPlans(0)
	]
	}
	
	// ----------------------- selecting the potential plans ----------
	// first select the most relevant plan.
	selectPotentialPlans(_) <- subgoal(Subgoal,NewPr) and currentPlan(CurrentPlan,_) and curPriority(CurPr) | 
	{
	[
		//B(roundPriority(NewPr,RoundedPr));
		//print(roundedPriority(RoundedPr));
		B(selectPlan(NewPlanId, NewPr, Subgoal));
		print(selectPlan(NewPlanId,NewPr));
		
		SetNewPlan(NewPlanId);
		
		sharePlans(0);
		selectRelevantPlan(0)
	]
	}
	
	// ----------------------- sharing a plan, sending and receiving ----------
	sharePlans(_) <- newPlan(NewPlanId) and plan(NewPlanId, _, _, _, _) and teamMate(TeamMate) | {
	[
		send( TeamMate, inform, plan(NewPlanId) );
		PlanShared()
	]
	}
	
	message( TeamMate, inform, _, _, plan( CoPlanId ) ) <- teamMate( TeamMate ) | 
	{
	[
		SetCoPlan(CoPlanId);
		PlanRcvd()
	]
	}
	
	// -----------------------  select most relevant plan ----------
	// see flowchart on Google Docs for a better overview of this method
	selectRelevantPlan(_) <- planShared and planRcvd and 
					newPlan(OwnPlanId) 	and plan(OwnPlanId, OwnPr, OwnSubgoal, OwnJointPlan, OwnSinglePlan) and
					coPlan(CoPlanId) 	and plan(CoPlanId, CoPr, CoSubgoal, CoJointPlan, CoSinglePlan) |
	{
	[
		if B(not (OwnJointPlan = [])) then 
		{
			if B(not (CoJointPlan = [])) then
			{
				if B(OwnPr > CoPr) then
				{
					if B(not (CoSubgoal = defend)) then
					{
						setPlan(OwnPlanId, OwnJointPlan)
					} else {
						setPlan(OwnPlanId, OwnSinglePlan)
					}
				} else if B(OwnPr = CoPr) then 
				{
					setPlan(OwnPlanId, OwnSinglePlan)
				} else 
				{
					if B(not (OwnSubgoal = defend)) then
					{
						setPlan(CoPlanId, CoJointPlan)
					} else
					{
						setPlan(OwnPlanId, OwnSinglePlan)
					}
				}
			} else
			{
				if B(OwnPr < CoPr and not (CoSubgoal = defend)) then
				{
					setPlan(OwnPlanId, OwnJointPlan)
				} else
				{
					setPlan(OwnPlanId, OwnSinglePlan)
				}
			}
		} else
		{
			if B(not(CoJointPlan = []) and not(OwnSubGoal = defend)) then 
			{
				if B(CoPriority =< OwnPriority) then
				{
					setPlan(OwnPlanId, OwnSinglePlan)
				} else
				{
					setPlan(CoPlanId, CoJointPlan)
				}
			} else
			{
				setPlan(OwnPlanId, OwnSinglePlan)
			}
		}
	]
	}
	
	// ----------------------- execution of plan; only if it differs from the current plan -----------------
	setPlan(NewPlanId, NewPlan) <- currentPlan(CurrentPlanId, CurrentPlan) and baseCP([X,Y]) and coBase(CoX, CoY) |
	{
	[
		if B(not (NewPlanId = CurrentPlanId)) then 
		{
			SetPlan(NewPlanId, NewPlan)
		} 
		else 
		{
			continuePlan()
		};
		
		SetIdle()
	]
	}
	
	continuePlan() <- currentPlan(CurrentPlanId,Plan) | 
	{
		// Plan = [subplan1, subplan2, ....]
		skip
	}
	
	event( ownUnitDestroyed(UnitsLeft), starcraft ) <- true |
	{
		DestroyUnit()
	}
	
	event( teamMate( Teammate, CoBaseX, CoBaseY ), starcraft ) <- true |
	{
		SetTeamMate( Teammate );
		SetCoBase( CoBaseX , CoBaseY )
	}
	
	
	// ------ TODO: implement events that catch the plan information