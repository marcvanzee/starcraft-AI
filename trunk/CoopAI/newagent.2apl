
/* The agent is written exactly as explained in the document 
 * "Reasoning cycle" that can be found on Google Docs.
 *
 * ---------------------- reasoning cycle ----------------------------------------------------------
 *
 * the reasoning cycle can be found in the flow chart of Google docs
 *
 *
 * ---------------- explanation of beliefs that are used -----------------------------------------
 *
 * the character of the agent is defined as the willingness to attack (WTA) and it is 
 * assigned once when the game starts.
 * 		wta(X), with X € [0,1,..,10]
 *
 * There are two subgoals, which both are assigned a priority at the beginning of each update
 * the winning priority will be the goal that the agent will try to pursue
 * these are the subgoals together with their priority
 * the priority depends on the WTA and the current situation
 * 		subgoal(Subgoal, X), with Subgoal € [attack,defend] and X € [0,1,...,10]
 *
 * beliefs that are assigned to the agent at the beginning of the game and do not change
 * 		baseCP(X,Y)			center point of the base
 * 		numUnits(X)			number of units
 *
 * beliefs that are assigned to the agent are every game update
 * 		unitsCP(X,Y)     	center point of own units
 * 		baseHP(X)			health Points of the own base
 * 		numEnemyUnits(X)	number of enemy units that are currently visible
 * 		enemies(L)			a list that contains the location and the HP of the visible enemies
 *		enemyBases(L)		a list that contains the location and the HP of the visible bases of the enemy
 *
 */

BeliefUpdates:
	// initial beliefs, when game starts
	{true} 				SetTeamMate(X) 		{teamMate(X)}
	{true} 				SetWta(X) 			{wta(X)}
	{true} 				SetUnits(X)			{numUnits(X)}
	{true}				SetBaseCP(Pos)		{baseCP(Pos)}									// Pos = [X,Y]
	
	// updated beliefs, when game updates
	{numUnits(X)}		DestroyUnit()		{not numUnits(X), numUnits(X-1)}
	{baseHP(X)}			SetBaseHP(Y)		{not baseHP(X), baseHP(Y)}
	{ownCP(Pos)}		SetOwnCP(PosNew)	{not ownCP(Pos), ownCP(PosNew)}					// Pos,PosNew = [X,Y]
	{numEnemies(X)}		SetNumEnemies(Y)	{not numEnemies(X), numEnemies(Y) }
	{enemies(Pos)}		SetEnemies(PosNew)	{not enemies(Pos), enemies(PosNew)}
	{enemyBases(L)}		SetEnemyBases(Lnew)	{not enemyBases(L), enemyBases(Lnew)}
	
	// other beliefs, for internal processing
	{true}				SetBusy()			{busy}
	{true}				SetIdle()			{not busy}
	{subgoal(X,Y)}		SetSubgoal(X1,Y1)	{not subgoal(X,Y), subgoal(X1,Y1)}
	
	// plan beliefs, a plan consists of: currentPlan(Plan, Priority)
	{newPlan(X,Y)}		SetNewPlan(X2,Y2)		{not newPlan(X,Y), newPlan(X2,Y2)}
	
	{currentPlan(X)}	SetPlan(Y)			{not currentPlan(X), currentPlan(Y)}
	{jointPlan(X)}		SetJointPlan(Y)	{not jointPlan(X),jointPlan(Y)}
	{singlePlan(X)}		SetSinglePlan(Y)	{not singlePlan(X),singlePlan(Y)}
	
	{coJointPlan(X)}	SetCoPlan(Y)			{not coPlan(X), coPlan(Y)}
	{coSinglePlan(X)}	SetCoSinglePlan(Y)		{not coSinglePlan(X), coSinglePlan(Y)}
	{coSubgoal(X,Y)}	SetCoSubgoal(X1,Y1)		{not coSubgoal(X,Y), coSubgoal(X1,Y1)}
	
	{true}				PlanShared()		{planShared}
	{true}				PlanRcvd{}			{planRcvd}
	{true}				ResetComm()			{not planShared, not planRcvd}

Beliefs:
// beliefs required for belief updates
	numUnits(0).
	baseHP(0).
	ownCP(0).
	numEnemies(0).
	enemies(0).
	enemyBases(0).
	subgoal(0,0).
	
	newPlan(0).
	currentPlan(0).
	jointPlan(0).
	singlePlan(0).
	
	coJointPlan(0).
	coSinglePlan(0).
	coSubgoal(0,0).
	
	
	// description of the plans: plan(Identifier, Joint, Subgoal, Plan), where
	// Identifier: 	a number denoting the unique identity of the plan
	// Joint: 		a boolean denoting whether this is a joint plan or not
	// Subgoal:		the subgoal that this plan belongs to: attack/defend
	// Plan: 		the plan
	plan(0,single,attack,[]).
	plan(1,joint,defend,[]).
	plan(2,single,defend,[]).
	plan(3,sing;e,attack,[]).
	
Plans:
	@starcraft(hello(),_)
		
PC-rules:	
 	//----------------------- game initializes -------------------------------------------
	event(gameStarted( Wta, Units, BaseLocation ), starcraft) <- true |
	{
	[
		SetWta(Wta);
		SetUnits(Units);
		SetBaseCP(BaseLocation);
		print(gamestarted)
	]
	}

	// ----------------------- game update ---------------------------
	event(gameUpdate( UnitCP, BaseHP, NumEnemies, EnemyUnitList, EnemyBuildingList ), starcraft) <- wta(WTA) and not busy |
	{
	[
		SetBusy();
		
		// receive all information
		SetOwnCP(UnitCP);
		SetBaseHP(BaseHP);
		SetNumEnemies(NumEnemies);
		SetEnemies(EnemyUnitList);
		SetEnemyBases(EnemyBuildingList);
		
		// advance to next reasoning step
		determineSubgoals(0)
	]
	}
	
	// ----------------------- determine subgoal priorities ----------
	determineSubgoals(_) <- baseCP(BaseCP) and baseHP(BaseHP) and numUnits(NumUnits) and
							ownCP(UnitCP) and numEnemies(NumEnemies) and enemies(Enemies) and
							enemyBases(EnemyBases) and wta(WTA) | 
	{
	[	
		@starcraft(allocatePriorities( BaseCP, BaseHP, NumUnits, UnitCP, NumEnemies, Enemies, EnemyBases, WTA ), Ret);
		
		if B(Ret = [actionresult([AttackPr, DefendPr])]) then 
		{
			// choose the subgoal that has the highest priority
			if B(AttackPr > DefendPr) then {
				SetSubgoal(attack, AttackPr)
			} else {
				SetSubgoal(defend, DefendPr)
			}
		};

		selectPotentialPlans(0)
	]
	}
	
	// ----------------------- selecting the potential plans ----------
	// first select the most relevant plan. if this plan is a joint plan, select a
	selectPotentialPlans(_) <- subgoal(Subgoal,NewPr) and currentPlan(Plan,CurPr) | {
	[
		if B(NewPr < CurPr) then 
		{
			// TODO: add a procedure that will select a plan
			selectPlan(NewPlan);
			if B(plan(NewPlan,joint,_,_)) then
			{
				// we have selected a joint plan, so we need to set this properly
				SetJointPlan(NewPlan);
				
				// select a plan that is not a joint plan
				selectSinglePlan(
				
				
			
			SetSinglePlan(0,NewPr);
			
			// if this plan is a joint plan, we also need to select an alternative plan
			if B(plan(0,true,_,_)) then {
				// TODO: add a procedure that will select an alternative plan
				SetAlternativePlan(1);
			}
		} else {
			// don't change plan
			SetPotentialPlan(Plan,CurPr);
		}
		
		sharePlan(0)
	]
	}
	
	// ----------------------- sharing a plan, sending and receiving ----------
	sharePlan(_) <- potentialPlan(Plan,Pr) and teamMate(TeamMate) | {
	[
		send( TeamMate, inform, potentialPlan( Plan, Pr ) );
		PlanShared()
	]
	}
	
	message( TeamMate, potentialPlan(HisPlan, Priority) ) <- teamMate( TeamMate ) | 
	{
		SetCoPlan(HisPlan, Priority);
		PlanRcvd()
	}
	
	message( TeamMate, acceptJointPlan(MyPlan) ) <- teamMate( TeamMate ) | 
	{
		SetCoPlan(HisPlan, Priority);
		JointPlanRcvd()
	}
	
	message( TeamMate, declineJointPlan(MyPlan) ) <- teamMate( TeamMate ) | 
	{
		SetCoPlan(HisPlan, Priority);
		JointPlanRcvd()
	}
	
	// -----------------------  ----------
	true <- planShared and planRcvd and coPlan(HisPlan, HisPr) and subgoal(Subgoal, MyPr)| {
		if B((Subgoal = attack) and plan(HisPlan,true,_,_))
		{
			// if i am not planning to defend and if he is proposing a joint plan
			if B(HisPr > MyPr) 
			{
				// if his priority exceeds mine we will pursue his goal
				SetNewPlan(HisPlan, HisPr);
				send( TeamMate, inform, acceptJointPlan( HisPlan ) )
			} else 
			{
				// else we will decline his proposal
				send( TeamMate, inform, declineJointPlan( HisPlan ) )
	
	
	// ----------------------- reasoning step #2b, plan selection - own plans -----------------
	selectPlan() <- true | {
		print(selectingPlan)
	}
	
	event(ownUnitDestroyed(UnitsLeft), starcraft ) <- true |
	{
		DestroyUnit()
	}
	
	event( teamMate(Teammate), starcraft ) <- true |
	{
		SetTeamMate( Teammate )
	}