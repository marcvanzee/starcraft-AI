
/* The agent is written exactly as explained in the document 
 * "Reasoning cycle" that can be found on Google Docs.
 *
 * ---------------------- reasoning cycle ----------------------------------------------------------
 *
 * the reasoning cycle can be found in the flow chart of Google docs
 *
 *
 * ---------------- explanation of beliefs that are used -----------------------------------------
 *
 * the character of the agent is defined as the willingness to attack (WTA) and it is 
 * assigned once when the game starts.
 * 		wta(X), with X € [0,1,..,10]
 *
 * There are two subgoals, which both are assigned a priority at the beginning of each update
 * the winning priority will be the goal that the agent will try to pursue
 * these are the subgoals together with their priority
 * the priority depends on the WTA and the current situation
 * 		subgoal(Subgoal, X), with Subgoal € [attack,defend] and X € [0,1,...,10]
 *
 * beliefs that are assigned to the agent at the beginning of the game and do not change
 * 		baseCP(X,Y)			center point of the base
 * 		numUnits(X)			number of units
 *
 * beliefs that are assigned to the agent are every game update
 * 		unitsCP(X,Y)     	center point of own units
 * 		baseHP(X)			health Points of the own base
 * 		numEnemyUnits(X)	number of enemy units that are currently visible
 * 		enemies(L)			a list that contains the location and the HP of the visible enemies
 *		enemyBases(L)		a list that contains the location and the HP of the visible bases of the enemy
 *
 */

BeliefUpdates:
	// initial beliefs, when game starts
	{true} 				SetTeamMate(X) 		{teamMate(X)}
	{true} 				SetWta(X) 			{wta(X)}
	{true} 				SetUnits(X)			{numUnits(X)}
	{true}				SetBaseCP(Pos)		{baseCP(Pos)}									// Pos = [X,Y]
	
	// updated beliefs, when game updates
	{numUnits(X)}		DestroyUnit()		{not numUnits(X), numUnits(X-1)}
	{baseHP(X)}			SetBaseHP(Y)		{not baseHP(X), baseHP(Y)}
	{ownCP(Pos)}		SetOwnCP(PosNew)	{not ownCP(Pos), ownCP(PosNew)}					// Pos,PosNew = [X,Y]
	{numEnemies(X)}		SetNumEnemies(Y)	{not numEnemies(X), numEnemies(Y) }
	{enemies(Pos)}		SetEnemies(PosNew)	{not enemies(Pos), enemies(PosNew)}
	{enemyBases(L)}		SetEnemyBases(Lnew)	{not enemyBases(L), enemyBases(Lnew)}
	
	// other beliefs, for internal processing
	{true}				SetBusy()			{busy}
	{true}				SetIdle()			{not busy}
	{subgoal(X,Y)}		SetSubgoal(X1,Y1)	{not subgoal(X,Y), subgoal(X1,Y1)}
	{curPriority(X)}	RememberPriority(Y)	{not curPriority(X), curPriority(Y)}
	
	// plan beliefs, a plan consists of: currentPlan(Plan, Priority)
	{currentPlan(X)}	SetPlan(Y)			{not currentPlan(X), currentPlan(Y)}
	
	{jointPlan(X)}		SetJointPlan(Y)		{not jointPlan(X),jointPlan(Y)}
	{singlePlan(X)}		SetSinglePlan(Y)	{not singlePlan(X),singlePlan(Y)}
	{newPlan(X,Y)}		SetNewPlan(X2,Y2)	{not newPlan(X,Y), newPlan(X2,Y2)}
	
	{coJointPlan(X)}	SetCoJointPlan(Y)	{not coPlan(X), coPlan(Y)}
	{coSinglePlan(X)}	SetCoSinglePlan(Y)	{not coSinglePlan(X), coSinglePlan(Y)}
	{coSubgoal(X,Y)}	SetCoSubgoal(X1,Y1)	{not coSubgoal(X,Y), coSubgoal(X1,Y1)}
	
	{true}				PlanShared()		{planShared}
	{true}				PlanRcvd()			{planRcvd}
	{true}				ResetComm()			{not planShared, not planRcvd}

Beliefs:
// beliefs required for belief updates
	numUnits(0).
	baseHP(0).
	ownCP(0).
	numEnemies(0).
	enemies(0).
	enemyBases(0).
	subgoal(0,0).
	curPriority(0).
	
	newPlan(0).
	currentPlan(0).
	jointPlan(0).
	singlePlan(0).
	
	coJointPlan(0).
	coSinglePlan(0).
	coSubgoal(0,0).
	
	selectPlan(X) :- is(X,0).
	selectSinglePlan(X) :- is(X,1).
	
	
	// description of the plans: plan(Identifier, Joint, Subgoal, Plan), where
	// Identifier: 	a number denoting the unique identity of the plan
	// Joint: 		a boolean denoting whether this is a joint plan or not
	// Subgoal:		the subgoal that this plan belongs to: attack/defend
	// Plan: 		the plan
	plan(0,single,attack,[]).
	plan(1,joint,defend,[]).
	plan(2,single,defend,[]).
	plan(3,sing;e,attack,[]).
	
Plans:
	@starcraft(hello(),_)

PC-rules:	
 	//----------------------- game initializes -------------------------------------------
	event(gameStarted( Wta, Units, BaseLocation ), starcraft) <- true |
	{
	[
		SetWta(Wta);
		SetUnits(Units);
		SetBaseCP(BaseLocation);
		print(gamestarted)
	]
	}

	// ----------------------- game update ---------------------------
	event(gameUpdate( UnitCP, BaseHP, NumEnemies, EnemyUnitList, EnemyBuildingList ), starcraft) <- wta(WTA) and not busy |
	{
	[
		SetBusy();
		
		// receive all information
		SetOwnCP(UnitCP);
		SetBaseHP(BaseHP);
		SetNumEnemies(NumEnemies);
		SetEnemies(EnemyUnitList);
		SetEnemyBases(EnemyBuildingList);
		
		// advance to next reasoning step
		determineSubgoals(0)
	]
	}

	// ----------------------- determine subgoal priorities ----------
	determineSubgoals(_) <- baseCP(BaseCP) and baseHP(BaseHP) and numUnits(NumUnits) and
							ownCP(UnitCP) and numEnemies(NumEnemies) and enemies(Enemies) and
							enemyBases(EnemyBases) and wta(WTA) and subgoal(_,CurPr) | 
	{
	[	
		@starcraft(allocatePriorities( BaseCP, BaseHP, NumUnits, UnitCP, NumEnemies, Enemies, EnemyBases, WTA ), Ret);
		
		// remember the current priority to compare later
		RememberPriority(CurPr);
		
		if B(Ret = [actionresult([AttackPr, DefendPr])]) then 
		{
			// choose the subgoal that has the highest priority
			if B(AttackPr > DefendPr) then {
				SetSubgoal(attack, AttackPr)
			} else {
				SetSubgoal(defend, DefendPr)
			}
		};

		selectPotentialPlans(0)
	]
	}
	
	// ----------------------- selecting the potential plans ----------
	// first select the most relevant plan. if this plan is a joint plan, select a
	selectPotentialPlans(_) <- subgoal(Subgoal,NewPr) and currentPlan(CurrentPlan) and curPriority(CurPr) | 
	{
		if B(NewPr < CurPr) then 
		{
			B(selectPlan(NewPlan));				// TODO: implement this procedure
			if B(plan(NewPlan,joint,_,_)) then
			{
				// we have selected a joint plan, so we need to set this properly
				SetJointPlan(NewPlan);
				
				// select a plan that is not a joint plan as a backup plan
				B(selectSinglePlan(SinglePlan));	// TODO: implement this procedure
				SetSinglePlan(SinglePlan)
			} else 
			{
				// we have selected a single plan, so we need to empty the joint plan
				SetJointPlan([])
			}
		} else {
			// use the current plan as the new plan
			SetSinglePlan(CurrentPlan);
			
			// dont use a joint plan
			SetJointPlan([])
		};
		sharePlans(0);
		selectRelevantPlan(0)
	}
	
	// ----------------------- sharing a plan, sending and receiving ----------
	sharePlans(_) <- jointPlan(JointPlan) and singlePlan(SinglePlan) and subgoal(Subgoal,Pr) and teamMate(TeamMate) | {
	[
		send( TeamMate, inform, plans(jointPlan(JointPlan),singlePlan(SinglePlan),subgoal(Subgoal,Pr)) );
		PlanShared()
	]
	}
	
	message( TeamMate, inform, _, _, plans(jointPlan(JointPlan),singlePlan(SinglePlan),subgoal(Subgoal,Pr)) ) <- teamMate( TeamMate ) | 
	{
	[
		SetCoJointPlan(JointPlan);
		SetCoSinglePlan(SinglePlan);
		SetCoSubgoal(Subgoal,Pr);
		PlanRcvd()
	]
	}
	
	// -----------------------  select most relevant plan ----------
	// see flowchart on Google Docs for a better overview of this method
	selectRelevantPlan(_) <- planShared and planRcvd and 
					jointPlan(OwnJointPlan) and singlePlan(OwnSinglePlan) and subgoal(OwnSubgoal,OwnPr) and
					coJointPlan(CoJointPlain) and coSinglePlan(CoSinglePlan) and coSubgoal(CoSubgoal,CoPr) |
	{
		if B(not (OwnJointPlan = [])) then 
		{
			if B(not (CoJointPlan = [])) then
			{
				if B(OwnPr > CoPr) then
				{
					if B(not (CoSubgoal = defend)) then
					{
						setPlan(OwnJointPlan)
					} else {
						setPlan(OwnSinglePlan)
					}
				} else if B(OwnPr = CoPr) then 
				{
					setPlan(OwnSinglePlan)
				} else 
				{
					if B(not (OwnSubgoal = defend)) then
					{
						setPlan(CoJointPlan)
					} else
					{
						setPlan(OwnSinglePlan)
					}
				}
			} else
			{
				if B(OwnPr < CoPr and not (CoSubgoal = defend)) then
				{
					setPlan(OwnJointPlan)
				} else
				{
					setPlan(OwnSinglePlan)
				}
			}
		} else
		{
			if B(not(CoJointPlan = []) and not(OwnSubGoal = defend)) then 
			{
				if B(CoPriority =< OwnPriority) then
				{
					setPlan(OwnSinglePlan)
				} else
				{
					setPlan(CoJointPlan)
				}
			} else
			{
				setPlan(OwnSinglePlan)
			}
		}
	}
	
	// ----------------------- execution of plan; only if it differs from the current plan -----------------
	setPlan(NewPlan) <- currentPlan(CurrentPlan) |
	{
		if B(not (NewPlan = CurrentPlan)) then {
			SetPlan(NewPlan)
		} else {
			// TODO: continue with the current plan
			skip
		};
		
		SetIdle()
	}
	
	// ------------ TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
	// ------------ TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
	// ------------ These two methods
	
	// ----------------------- plan selection - select the plan that is most applicable to the current context -----------------
	//selectPlan(X) <- true | {
	//	skip
	//}
	
	// ----------------------- plan selection - select the plan that is most applicable to the current context and thats NOT a joint plan 
	//selectSinglePlan(X) <- true | {
	//	is(X, 0)
	//}	
	
	
	
	event(ownUnitDestroyed(UnitsLeft), starcraft ) <- true |
	{
		DestroyUnit()
	}
	
	event( teamMate(Teammate), starcraft ) <- true |
	{
		SetTeamMate( Teammate )
	}